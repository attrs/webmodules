"use strict";

var ARRAY_LIKE = ['[object Array]', '[object HTMLCollection]', '[object NodeList]', '[object Arguments]'];
var isArrayLike = function(o) {
  if( !o ) return false;
  if( ~ARRAY_LIKE.indexOf(Object.prototype.toString.call(o)) ) return true;
  if( Array.isArray && Array.isArray(o) ) return true;
  if( o.constructor && o.constructor.prototype instanceof Array ) return true;
  
  return false;
}

var clone = function(o, deep, allprototype) {
  if( isArrayLike(o) ) return [].slice.call(o);
  if( typeof(o) !== 'object' ) return o;
  
  var n = {};
  for(var k in o) {
    if( !o.hasOwnProperty(k) && !allprototype ) continue;
    if( deep === true ) n[k] = clone(o[k]);
    else n[k] = o[k];
  }
  
  return n;
}
var mixin = function() {
  var result;
  [].forEach.call(arguments, function(o) {
    if( o && typeof o === 'object' ) {
      if( !result ) return result = o;
      for(var k in o) result[k] = o[k];
    }
  });
  return result;
}

var removeItem = function(array, item, once) {
  if( !isArrayLike(array) ) return null;
  
  var removed = [];
  for(var index;(index = array.indexOf(item)) >= 0;) {
    removed.push(array.splice(index, 1));
    if( once ) break;
  }
  return removed;
}

var outline = function(fn) {
  if( typeof(fn) !== 'function' ) return fn;

  var o = new (function Static(){});
  for(var k in fn) {
    if( !fn.hasOwnProperty(k) ) continue;
    o[k] = fn[k];
  }

  return o;
}

var camelcase = function(value, firstlower, delimeter){
  if( !delimeter ) delimeter = '-';
  var result = value.replace(/(\-[a-z])/g, function($1){return $1.toUpperCase().replace(delimeter,'');});
  if( !result ) return result;
  if( firstlower ) return result;
  return result.substring(0,1).toUpperCase() + result.substring(1);
};

var uncamelcase = function(value, delimeter){
  if( !delimeter ) delimeter = '-';
  var result = value.replace(/([A-Z])/g, function($1){return (delimeter + $1).toLowerCase();});
  if( value[0] !== '-' && result[0] === '-' ) result = result.substring(1);
  return result;
};

var currency = function(n, f){
  var c, d, t;

  var n = n, c = isNaN(c = Math.abs(c)) ? 2 : c, d = d == undefined ? "." : d, t = t == undefined ? "," : t, s = n < 0 ? "-" : "", i = parseInt(n = Math.abs(+n || 0).toFixed(c)) + "", j = (j = i.length) > 3 ? j % 3 : 0;
  return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + ((f===false) ? '' : (c ? d + Math.abs(n - i).toFixed(c).slice(2) : ""));
}

var seal = function(o, names, config) {
  if( typeof names === 'string' ) names = [names];
      
  var cfg = {
    enumerable: false,
    configurable: false,
    writable: false
  };
  
  for(var k in config) {
    var v = config[k];
    if( k == 'g' ) k = 'get';
    else if( k == 's' ) k = 'set';
    else if( k == 'e' ) k = 'enumerable';
    else if( k == 'c' ) k = 'configurable';
    else if( k == 'w' ) k = 'writable';
    else if( k == 'v' ) k = 'value';
    cfg[k] = v;
  }
  
  names.forEach(function(name) {
    cfg.value = o[name];
    if( name in o ) Object.defineProperty(o, name, cfg);
    else console.error('seal property "' + name + '" not defined');
  });
};

var define = function(o, name, config) {
  var cfg = {};
  for(var k in config) {
    var v = config[k];
    if( k == 'g' ) k = 'get';
    else if( k == 's' ) k = 'set';
    else if( k == 'e' ) k = 'enumerable';
    else if( k == 'c' ) k = 'configurable';
    else if( k == 'w' ) k = 'writable';
    else if( k == 'v' ) k = 'value';
    cfg[k] = v;
  }
  
  Object.defineProperty(o, name, cfg);
};

var strip = function(value, mark) {
  if( typeof value !== 'string' ) return value;
  if( !mark || typeof mark !== 'string' ) return value;
      
  value = value.trim();
  if( value.indexOf(mark) === 0 && value.lastIndexOf(mark) === (value.length - mark.length) ) return value.substring(mark.length, value.length - mark.length);
  
  return value;
};

var started = Date.now();
var elapsed = function() {
  return Date.now() - started;
};

elapsed.start = function() {
  var started = Date.now();
  return {
    finish: function() {
      return Date.now() - started;
    }
  }
};

var evaluateType = function(type, value, format) {
  if( !type ) return value;
  if( value === null ) {
    if( type === 'boolean' ) return false;
    return null;
  }
  
  if( type === 'default' ) value = value === '' ? true : value;
  else if( type === 'boolean' ) value = (value !== null ? (value.toLowerCase().trim() === 'false' ? false : true) : false);
  else if( type === 'number' ) value = ~value.indexOf('.') ? parseFloat(value) : parseInt(value);
  else if( type === 'currency' ) value = currency(value, format === true ? true : false);
  else if( type === 'array' ) value = value.split(',');
  else if( type === 'int' ) value = parseInt(value);
  else if( type === 'float' ) value = parseFloat(value);
  else if( type === 'date' ) value = new Date(isNaN(parseInt(value)) ? value : parseInt(value)).format(format);
  else if( type === 'element' ) value = document.querySelector(value);
  else if( type === 'elements' ) value = document.querySelectorAll(value);
  else if( type === 'base64' || type === 'atob' ) value = atob(value);
  else if( type === 'json' ) value = JSON.parse(value);
  else if( type === 'script' ) value = eval('value = ' + value + ';');
  else if( type === 'arguments' ) arg = value = value.split(',');
  else if( type === 'btoa' ) value = btoa(value);
  else if( type === 'string' ) value = value && value.toString();
  else return console.error('unknown type', type, value);
  return value;
}

module.exports = {
  mixin: mixin,
  clone: clone,
  currency: currency,
  price: currency,
  camelcase: camelcase,
  uncamelcase: uncamelcase,
  outline: outline,
  seal: seal,
  define: define,
  removeItem: removeItem,
  isArrayLike: isArrayLike,
  strip: strip,
  stripQuot: function(value) {
    value = strip(value, '\"');
    value = strip(value, '\'');
    return value;
  },
  elapsed: elapsed,
  evaluateType: evaluateType
};

/*
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}

if( !String.prototype.startsWith ) {
  String.prototype.startsWith = function(s) {
    return this.indexOf(s) === 0;
  };
}

if( !String.prototype.endsWith ) {
  String.prototype.endsWith = function(s) {
    var t = String(s);
    var index = this.lastIndexOf(t);
    return index >= 0 && index === this.length - t.length;
  };
}

if ( !Array.prototype.every ) {
  Array.prototype.every = function(fun) {
    'use strict';
    
    if (this === void 0 || this === null) throw new TypeError();
    
    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function') throw new TypeError();
    
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++) {
      if (i in t && !fun.call(thisArg, t[i], i, t))
        return false;
    }
    
    return true;
  };
}

/* Production steps of ECMA-262, Edition 6, 22.1.2.1
// Reference: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.from
if (!Array.from) {
  Array.from = (function () {
    var toStr = Object.prototype.toString;
    var isCallable = function (fn) {
      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
    };
    var toInteger = function (value) {
      var number = Number(value);
      if (isNaN(number)) { return 0; }
      if (number === 0 || !isFinite(number)) { return number; }
        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
      };
      var maxSafeInteger = Math.pow(2, 53) - 1;
      var toLength = function (value) {
      var len = toInteger(value);
      return Math.min(Math.max(len, 0), maxSafeInteger);
    };
    
    return function from(arrayLike) {
      var C = this;
      var items = Object(arrayLike);
      if (arrayLike == null) {
        throw new TypeError("Array.from requires an array-like object - not null or undefined");
      }
    
      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
      var T;
      if (typeof mapFn !== 'undefined') {
        if (!isCallable(mapFn)) {
          throw new TypeError('Array.from: when provided, the second argument must be a function');
        }
      
        if (arguments.length > 2) {
          T = arguments[2];
        }
      }
    
      var len = toLength(items.length);
      var A = isCallable(C) ? Object(new C(len)) : new Array(len);
      var k = 0;
      var kValue;
      while (k < len) {
        kValue = items[k];
        if (mapFn) {
          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
        } else {
          A[k] = kValue;
        }
        k += 1;
      }
      A.length = len;
      return A;
    };
  }());
}*/
