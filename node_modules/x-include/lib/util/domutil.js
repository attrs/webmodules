"use strict"

var slice = [].slice;
var each = [].forEach;

var removeItem = function(array, item, once) {
  if( !isArrayLike(array) ) return null;
  
  var removed = [];
  for(var index;(index = array.indexOf(item)) >= 0;) {
    removed.push(array.splice(index, 1));
    if( once ) break;
  }
  return removed;
}

var ARRAY_LIKE = ['[object Array]', '[object HTMLCollection]', '[object NodeList]', '[object Arguments]'];
var isArrayLike = function(o) {
  if( !o ) return false;
  if( ~ARRAY_LIKE.indexOf(Object.prototype.toString.call(o)) ) return true;
  if( Array.isArray && Array.isArray(o) ) return true;
  if( o.constructor && o.constructor.prototype instanceof Array ) return true;
  
  return false;
}

var markup = function(html, onlyelements) {
  if( typeof(html) !== 'string' ) return null;
  
  var fragment = document.createDocumentFragment();
  
  var lower = html.trim().toLowerCase();
  var el;
  if( !lower.indexOf('<tr') ) el = document.createElement('tbody');
  else if( !lower.indexOf('<tbody') || !lower.indexOf('<thead') || !lower.indexOf('<tfoot') ) el = document.createElement('table');
  else if( !lower.indexOf('<td') ) el = document.createElement('tr');
  else el = document.createElement('div');

  el.innerHTML = html;

  var children = (onlyelements === true) ? el.children : el.childNodes;
  if( children ) {
    for(var i=0; i < children.length; i++) {
      fragment.appendChild(children[i]);
    }
  }

  return fragment;
};

var computed = function(el, k) {
  var cs;
  if( window.getComputedStyle ) {
    cs = getComputedStyle(el);
  } else if ( el.currentStyle ) {
    cs = el.currentStyle;
  } else {
    return console.error('browser not support computed style');
  }

  return k ? cs[k] || (cs.getPropertyValue && cs.getPropertyValue(k)) : cs;
};

  var matchesselectorfn;
['matches','webkitMatchesSelector','mozMatchesSelector','msMatchesSelector','oMatchesSelector'].some(function(fn) {
      if (typeof document.createElement('div')[fn] == 'function') {
          matchesselectorfn = fn;
          return true;
      }
      return false;
  });

var matchesSelector = function(element, selector) {
  if( selector === '*' ) return true;
  if( !element ) return false;
  if( !selector ) return false;  
  if( matchesselectorfn ) return element[matchesselectorfn](selector);    
  var matches = (element.document || element.ownerDocument).querySelectorAll(selector);
  var i = 0;
  while(matches[i] && matches[i] !== element) i++;
  return matches[i] ? true : false;
};

var closest = function(element, selector) {
  if( typeof element === 'string' ) {
    selector = element;
    element = document._currentScript || document.currentScript;
  }
  
  //console.log(element, element.parentNode, selector);
  
  //if( element.closest ) return element.closest(selector);
  
  // 현재 부모의 아래에서 제일 가까운 자식으로 먼저 찾고 없으면, document 에서 찾는다.
  var found, parent = element.parentNode, fn = selector;
  
  if( typeof selector === 'string' ) fn = function(current) {
    return current.querySelector(selector);
  }
  
  if( typeof fn !== 'function' ) return console.error('argument selector must be a string or function', selector);
  
  do {
    found = fn(parent);
    if( found ) return found;
  } while( (parent = parent.parentNode ) );
  
  return null;
};

var accessor = function(el) {
  var tag = el.tagName.toLowerCase();
  var id = el.id;
  var cls = el.className.split(' ').join('.');
  id = id ? ('#' + id) : '';
  cls = cls ? ('.' + cls) : '';

  return tag + id + cls;
};

var assemble = function(selector) {
  if( !selector || typeof(selector) !== 'string' ) return console.error('invalid selector', selector);

  var arr = selector.split(':');

  var accessor = arr[0];
  var pseudo = arr[1];

  arr = accessor.split('.');
  var tag = arr[0];
  var id;
  var classes = arr.splice(1).join(' ').trim();

  if( ~tag.indexOf('#') ) {
    var t = tag.split('#');
    tag = t[0];
    id = t[1];
  }

  return {
    selector: selector,
    accessor: accessor,
    tag: tag && tag.toLowerCase() || '',
    id: id || '',
    classes: classes || '',
    pseudo: pseudo || ''
  };
};

var addClass = function(el, classes) {
  var elcls = el.className.split(' ');
  if( !~classes.indexOf(' ') ) ~elcls.indexOf(classes) ? true : false;
  
  classes.split(' ').forEach(function(cls) {
    if( cls && !~elcls.indexOf(cls) ) elcls.push(cls);
  });
  
  el.className = elcls.join(' ');    
  return el;
};

var removeClass = function(el, classes) {
  var elcls = el.className.split(' ');
  if( !~classes.indexOf(' ') ) ~elcls.indexOf(classes) ? true : false;
  
  classes.split(' ').forEach(function(cls) {
    if( cls && ~elcls.indexOf(cls) ) removeItem(elcls, cls);
  });
  
  el.className = elcls.join(' ');    
  return el;
};

var hasClass = function(el, classes) {
  var elcls = el.className.split(' ');
  if( !~classes.indexOf(' ') ) ~elcls.indexOf(classes) ? true : false;
  
  var hasnot = false;
  classes.split(' ').forEach(function(cls) {
    if( !cls || !~elcls.indexOf(cls) ) hasnot = true;
  });
  
  return !hasnot;
};

var stringify = function(el) {
  if( el.outerHTML ) {
    return el.outerHTML;
  } else {
    var p = el.parent();
    if( p ) {
      return p.html();
    } else {
      var html = '<' + el.tagName;
  
      if( el.style ) html += ' style="' + el.style + '"';
      if( el.className ) html += ' class="' + el.className + '"';
  
      var attrs = el.attributes;
      for(var k in attrs) {
        if( !attrs.hasOwnProperty(k) ) continue;
        if( k && attrs[k] ) {
          html += ' ' + k + '="' + attrs[k] + '"';
        }
      }

      html += '>';
      html += el.innerHTML;
      html += '</' + el.tagName + '>';

      return html;
    }
  }
};

var isShowing = function (el) {
  if( computed(el, 'visibillity') === 'hidden' ) return false;
  if( (el.scrollWidth || el.scrollHeight || el.offsetWidth || el.offsetHeight || el.clientWidth || el.clientHeight) ) return true;
  return false;
};

var boundary = function(el) {
  if( !el ) return console.error('invalid parameter', el);

  var abs = function(el) {
    var position = { x: el.offsetLeft, y: el.offsetTop };
    if (el.offsetParent) {
      var tmp = abs(el.offsetParent);
      position.x += tmp.x;
      position.y += tmp.y;
    }
    return position;
  };

  var boundary = {
    x: 0,
    y: 0,
    width: el.offsetWidth,
    height: el.offsetHeight,
    scrollWidth: el.scrollWidth,
    scrollHeight: el.scrollHeight,
    clientWidth: el.clientWidth,
    clientHeight: el.clientHeight
  };

  if( el.parentNode ) {
    boundary.x = el.offsetLeft + el.clientLeft;
    boundary.y = el.offsetTop + el.clientTop;
    if( el.offsetParent ) {
      var parentpos = abs(el.offsetParent);
      boundary.x += parentpos.x;
      boundary.y += parentpos.y;
    }
  }
  return boundary;
};

var normalizeContentType = function(mimeType, url) {
  if( mimeType && typeof(mimeType) === 'string' ) {
    mimeType = mimeType.split(';')[0];
  
    if( ~mimeType.indexOf('javascript') ) return 'js';
    else if( ~mimeType.indexOf('html') ) return 'html';
    else if( ~mimeType.indexOf('json') ) return 'json';
    else if( ~mimeType.indexOf('xml') ) return 'xml';
    else if( ~mimeType.indexOf('css') ) return 'css';
    else return mimeType;
  } else if( url && typeof(url) === 'string' ) {
    var match = url.match(/\.([0-9a-z]+)(?:[\?#]|$)/i);      
    var ext = ((match && match[1]) || '').toLowerCase();
    if( ext === 'htm') return 'html';
    else return ext;
  } else {
    return console.error('illegal parameter', mimeType, url);
  }
};

var wrappingstringevent = function(script) {
  return function(e) {
    return eval(script);
  };
};

var mixselector = function(baseAccessor, selector) {
  // base accessor : .app-x.application
  // selector : div#id.a.b.c[name="name"]
  // result = div#id.app-x.application.a.b.c[name="name"]      
  selector = selector || '*';
  if( selector === '*' ) return baseAccessor;
  else if( !~selector.indexOf('.') ) return selector + baseAccessor;

  var h = selector.substring(0, selector.indexOf('.'));
  var t = selector.substring(selector.indexOf('.'));
  return h + baseAccessor + t;
};

var isNode = function(o){
  return o && (typeof o === 'object') && (typeof window.Node === 'object') ? o instanceof window.Node : (typeof o.nodeType === 'number' && typeof o.nodeName === 'string');
};

var isElement = function(el) {
  return isNode(el) && el.nodeType == 1;
};

var isHtml = function (html) {
  return (typeof html === 'string' && html.match(/(<([^>]+)>)/ig) ) ? true : false;
};

var position = function(element, startelement) {
    var x = 0;
    var y = 0;
  
  //console.log(element.getBoundingClientRect(), element.getClientRects());
  
    while(element) {
    //console.debug('current', element, element.matches(':host::shadow *'));
    
    // 시작점이 있다면, 시작노드 하위에 있다면 계속, 현재 엘리먼트가 쉐도우노드 일때는 부모가 나올때까지 계속
    if( !element.matches(':host::shadow *') && (startelement && (element === startelement || !startelement.contains(element))) ) break;
    
        x += (element.offsetLeft - element.scrollLeft + element.clientLeft);
        y += (element.offsetTop - element.scrollTop + element.clientTop);
    
        element = element.offsetParent;
    
    //console.log('pass', x,y,element);
    }
  console.log('x/y', x, y);
    return { x: x, y: y };
};

// visit  
var visit = function(dom, fn, allnode) {
  if( dom ) {
    var nodes = allnode ? (dom.childNodes || dom.children) : dom.children;      
    if( !allnode && dom.nodeType === 1 && fn.call(dom) === false ) return;
    else if( allnode && fn.call(dom) === false ) return;

    //console.log('nodes', nodes);
    if( nodes ) {
      slice.call(nodes).forEach(function(child) {
        visit(child, fn, allnode);
      });
    }
  }
};

var visitup = function(dom, fn) {
  if( fn.call(dom) === false ) return;
  
  var p = dom && dom.parentNode;
  if( p ) visitup(p, fn);
};

var visitoffset = function(dom, fn) {
  if( fn.call(dom) === false ) return;
  
  var p = dom && dom.offsetParent;
  if( p ) visitoffset(p, fn);
};

// events
var customeventshandlers = {};
var fire = function(dom, type, detail, cancelable, bubbles) {
  if( typeof type !== 'string' ) return console.error('invalid event type', type);
  
  var event;
  if( window.Event && detail instanceof Event ) {
    event = detail;
  } else if( window.CustomEvent ) {
    event = new CustomEvent(type, {bubbles:bubbles, cancelable:cancelable, detail: detail});
  } else if( document.createEvent ) {
    event = document.createEvent('Event');
    event.initEvent(type, bubbles, cancelable);
    event.detail = detail;
  }
  
  dom.dispatchEvent(event);    
  return event;
};

var firedown = function(dom, type, detail, cancelable) {    
  visit(dom, function() {
    if( this.nodeType === 1 ) fire(this, type, detail, cancelable);
  });
};

var on = function(dom, types, fn, capture) {
  if( typeof types !== 'string' ) return console.error('invalid event type', types);
  
  types.split(' ').forEach(function(type) {
    if( !type ) return;
    type = type.toLowerCase();
    
    var handler = customeventshandlers[type];
    if( handler && handler.add ) {
      handler.add.apply(dom, [type, fn, capture]);
    } else {
      dom.addEventListener(type, fn, capture);
    }
  });
};

var off = function(dom, types, fn, capture) {
  if( typeof types !== 'string' ) return console.error('invalid event type', types);
  
  types.split(' ').forEach(function(type) {
    if( !type ) return;
    type = type.toLowerCase();
    
    var handler = customeventshandlers[type];
    if( handler && handler.remove ) {
      handler.remove.apply(dom, [type, fn, capture]);
    } else {
      dom.removeEventListener(type, fn, capture);
    }
  });
};

var customevents = function(types, handler) {
  if( !arguments.length ) return customeventshandlers;
  if( arguments.length === 1 ) return customeventshandlers[types.toLowerCase()];
  
  types.split(' ').forEach(function(type) {
    type = type && type.toLowerCase().trim();
    if( type ) customeventshandlers[type] = handler;
  });
  return handler;
};

// override original addEventListener/removeEventListener
(function() {
  // ie <= 8 shim (from https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.addEventListener#Compatibility)
  if (!Event.prototype.preventDefault) {
    Event.prototype.preventDefault=function() {
      this.returnValue=false;
    };
  }
  if (!Event.prototype.stopPropagation) {
    Event.prototype.stopPropagation=function() {
      this.cancelBubble=true;
    };
  }
  if (!Element.prototype.addEventListener) {
    var eventListeners=[];

    var addEventListener = function(type,listener /*, useCapture (will be ignored) */) {
      var self = this;
      var wrapper = function(e) {
        e.target = e.srcElement;
        e.currentTarget=self;
        if (listener.handleEvent) {
          listener.handleEvent(e);
        } else {
          listener.call(self,e);
        }
      };
      if (type=="DOMContentLoaded") {
        var wrapper2 = function(e) {
          if (document.readyState == "complete") {
            wrapper(e);
          }
        };
        document.attachEvent("onreadystatechange",wrapper2);
        eventListeners.push({object:this,type:type,listener:listener,wrapper:wrapper2});

        if (document.readyState=="complete") {
          var e=new Event();
          e.srcElement=window;
          wrapper2(e);
        }
      } else {
        this.attachEvent("on"+type,wrapper);
        eventListeners.push({object:this,type:type,listener:listener,wrapper:wrapper});
      }
    };
  
    var removeEventListener=function(type,listener /*, useCapture (will be ignored) */) {
      var counter=0;
      while (counter<eventListeners.length) {
        var eventListener=eventListeners[counter];
        if (eventListener.object==this && eventListener.type==type && eventListener.listener==listener) {
          if (type=="DOMContentLoaded") {
            this.detachEvent("onreadystatechange",eventListener.wrapper);
          } else {
            this.detachEvent("on"+type,eventListener.wrapper);
          }
          eventListeners.splice(counter, 1);
          break;
        }
        ++counter;
      }
    };
  
    Element.prototype.addEventListener=addEventListener;
    Element.prototype.removeEventListener=removeEventListener;
    
    if (HTMLDocument) {
      HTMLDocument.prototype.addEventListener=addEventListener;
      HTMLDocument.prototype.removeEventListener=removeEventListener;
    }
    if (Window) {
      Window.prototype.addEventListener=addEventListener;
      Window.prototype.removeEventListener=removeEventListener;
    }
  }
  
  var addEventListener = HTMLElement.prototype.addEventListener;
  var removeEventListener = HTMLElement.prototype.removeEventListener;
  
  if( addEventListener.original ) addEventListener = addEventListener.original;
  if( removeEventListener.original ) removeEventListener = removeEventListener.original;
  
  var proxyAddEventListener = function(type, fn, capture) {
    var handler;
    if( type && (handler = customeventshandlers[type.toLowerCase()]) && handler.add ) {
      HTMLElement.prototype.addEventListener = addEventListener;
      handler.add.apply(this, arguments);
      HTMLElement.prototype.addEventListener = proxyAddEventListener;
    } else {
      addEventListener.apply(this, arguments);
    }
  };
  
  var proxyRemoveEventListener = function(type, fn, capture) {
    var handler;
    if( type && (handler = customeventshandlers[type.toLowerCase()]) && handler.remove ) {
      HTMLElement.prototype.removeEventListener = removeEventListener;
      handler.remove.apply(this, arguments);
      HTMLElement.prototype.removeEventListener = proxyRemoveEventListener;
    } else {
      removeEventListener.apply(this, arguments);
    }
  };
  
  proxyAddEventListener.original = addEventListener;
  proxyRemoveEventListener.proxy = removeEventListener;
  
  HTMLElement.prototype.addEventListener = proxyAddEventListener;
  HTMLElement.prototype.removeEventListener = proxyRemoveEventListener;
})();

var data = function(element, key, value) {
  if( !element ) return null;
  if( arguments.length === 1 ) return element.__attrs__;
  if( arguments.length === 2 ) return element.__attrs__ && element.__attrs__[key];
  
  if( !element.__attrs__ ) element.__attrs__ = {};

  if( value !== false || value !== undefined ) {
    element.__attrs__[key] = value;
  } else {
    element.__attrs__[key] = undefined;
    try {
      delete element.__attrs__[key];
    } catch(e) {}
  }
};

var datacall = function(elements, callback) {
  if( typeof(callback) !== 'function' ) return console.error('callback must be a function', callback);
  if( !isArrayLike(elements) ) elements = [elements];
  
  var result = [];
  each.call(elements, function(element) {
    result.push(callback.call(element, data(element, 'arg')));
  });
  return result;
};

var create = function(element, accessor, arg) {
  if( typeof element === 'string' ) {
    arg = accessor;
    accessor = element;
    element = null;
  }
  
  if( !accessor || typeof(accessor) !== 'string' ) return console.error('invalid parameter', accessor);
  
  var o = assemble(accessor);
  var tag = o.tag;
  var classes = o.classes;
  var id = o.id;

  if( !tag ) return console.error('illegal accessor(missing tag)', accessor);

  var el = document.createElement(tag);
  if( id ) el.id = id;
  if( classes ) el.className = classes;
  
  if( arg ) data(el, 'arg', arg);
  if( element ) element.appendChild(el);
  
  return el;
};

// animation
(function() {
  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating 
  // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel 
  // MIT license 
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                                   || window[vendors[x]+'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
            timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };

    if (!window.cancelAnimationFrame)
      window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
      };
}());

/* 
from jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
Copyright 짤 2008 George McGinley Smith
http://gsgd.co.uk/sandbox/jquery/easing/jquery.easing.1.3.js 
*/
var easing = {
  'ease-in': function (x, t, b, c, d) {
    return c*(t/=d)*t + b;
  },
  'ease-out': function (x, t, b, c, d) {
    return -c *(t/=d)*(t-2) + b;
  },
  'ease-in-out': function (x, t, b, c, d) {
    if ((t/=d/2) < 1) return c/2*t*t + b;
    return -c/2 * ((--t)*(t-2) - 1) + b;
  }
};

var anim = function(element, properties, easing) {
  var start;
  var step = function(timestamp) {
    if (!start) start = timestamp;
    var progress = timestamp - start;
    element.style.left = Math.min(progress/10, 200) + "px";
    if (progress < 2000) {
      window.requestAnimationFrame(step);
    }
  };
  
  return {
    start: function(fn) {
      window.requestAnimationFrame(step);
    }
  }
};

module.exports = {
  removeItem: removeItem,
  isArrayLike: isArrayLike,
  markup: markup,
  computed: computed,
  matches: matchesSelector,
  closest: closest,
  accessor: accessor,
  assemble: assemble,
  create: create,
  boundary: boundary,
  isShowing: isShowing,
  stringify: stringify,
  addClass: addClass,
  removeClass: removeClass,
  hasClass: hasClass,
  normalizeContentType: normalizeContentType,
  wrappingstringevent: wrappingstringevent,
  mixselector: mixselector,
  isNode: isNode,
  isElement: isElement,
  isHtml: isHtml,
  position: position,
  visit: visit,
  visitup: visitup,
  visitoffset: visitoffset,
  fire: fire,
  firedown: firedown,
  on: on,
  off: off,
  customevents: customevents,
  data: data,
  datacall: datacall,
  easing: easing,
  anim: anim
};
